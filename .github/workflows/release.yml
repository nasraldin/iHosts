name: Build and Release

on:
  push:
    tags:
      - "v*" # Trigger on version tags like v1.0.0, v1.0.1, etc.
  workflow_dispatch: # Allow manual triggering

jobs:
  build:
    runs-on: macos-latest
    permissions:
      contents: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "pnpm"

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Import code signing certificate
        env:
          CSC_LINK: ${{ secrets.CSC_LINK }}
          CSC_KEY_PASSWORD: ${{ secrets.CSC_KEY_PASSWORD }}
        run: |
          # Only import certificate if CSC_LINK is provided
          if [ -n "$CSC_LINK" ]; then
            echo "$CSC_LINK" | base64 --decode > certificate.p12
            security create-keychain -p "" build.keychain || true
            security default-keychain -s build.keychain
            security unlock-keychain -p "" build.keychain
            security import certificate.p12 -k build.keychain -P "$CSC_KEY_PASSWORD" -T /usr/bin/codesign || true
            security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "" build.keychain || true
            rm certificate.p12
          fi

      - name: Setup App Store Connect API key
        env:
          APPLE_API_KEY: ${{ secrets.APPLE_API_KEY }}
          APPLE_API_KEY_ID: ${{ secrets.APPLE_API_KEY_ID }}
        run: |
          # Only create API key file if both secrets are provided
          if [ -n "$APPLE_API_KEY" ] && [ -n "$APPLE_API_KEY_ID" ]; then
            # Create the API key file from secret (could be base64 or direct content)
            if echo "$APPLE_API_KEY" | base64 -d > /dev/null 2>&1; then
              echo "$APPLE_API_KEY" | base64 --decode > "AuthKey_${APPLE_API_KEY_ID}.p8"
            else
              echo "$APPLE_API_KEY" > "AuthKey_${APPLE_API_KEY_ID}.p8"
            fi
            chmod 600 "AuthKey_${APPLE_API_KEY_ID}.p8"
            echo "APPLE_API_KEY_PATH=$(pwd)/AuthKey_${APPLE_API_KEY_ID}.p8" >> $GITHUB_ENV
          fi

      - name: Build application
        run: |
          echo "Starting build process..."
          set -o pipefail
          pnpm run make 2>&1 | tee build.log || {
            echo "Build failed or incomplete. Checking status..."
            tail -100 build.log
            exit 1
          }
          echo ""
          echo "Build completed. Checking outputs..."
          echo "Packaged app location:"
          find ./out/package -name "*.app" -type d 2>/dev/null | head -5 || echo "No .app found"
          echo ""
          echo "ZIP files location:"
          find ./out -name "*.zip" -type f 2>/dev/null || echo "No ZIP files found"
          echo ""
          echo "Full out directory structure:"
          ls -laR ./out 2>/dev/null | head -50 || echo "No out directory"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          DEBUG: electron-forge:*
          ELECTRON_FORGE_DEBUG: "1"
          # Code signing environment variables
          CSC_IDENTITY: ${{ secrets.CSC_IDENTITY }}
          CSC_LINK: ${{ secrets.CSC_LINK }}
          CSC_KEY_PASSWORD: ${{ secrets.CSC_KEY_PASSWORD }}
          # Notarization environment variables (App Store Connect API key method - recommended)
          APPLE_API_KEY: ${{ env.APPLE_API_KEY_PATH }}
          APPLE_API_KEY_ID: ${{ secrets.APPLE_API_KEY_ID }}
          APPLE_API_ISSUER: ${{ secrets.APPLE_API_ISSUER }}
          # Alternative notarization method (App-specific password)
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}

      - name: Get version from package.json
        id: get_version
        run: |
          VERSION=$(cat package.json | grep -o '"version": "[^"]*"' | cut -d'"' -f4)
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=v$VERSION" >> $GITHUB_OUTPUT

      - name: Get tag name
        id: get_tag
        run: |
          if [ "${{ github.ref_type }}" == "tag" ]; then
            TAG_NAME="${{ github.ref_name }}"
          else
            VERSION=$(cat package.json | grep -o '"version": "[^"]*"' | cut -d'"' -f4)
            TAG_NAME="v$VERSION"
          fi
          echo "tag=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "Tag name: $TAG_NAME"

      - name: List build artifacts
        run: |
          echo "Searching for build artifacts..."
          find ./out -name "*.zip" -type f 2>/dev/null | head -20 || echo "No zip files found"
          echo ""
          echo "Directory structure:"
          ls -la ./out/make/zip/darwin/ 2>/dev/null || echo "Directory not found"
          echo ""
          echo "All zip files:"
          find ./out/make/zip -name "*.zip" -type f 2>/dev/null || echo "No zip files in expected location"
          echo ""
          echo "Checking for packaged app:"
          find ./out/package -name "*.app" -type d 2>/dev/null | head -5 || echo "No .app found"

      - name: Create ZIP if makers didn't run
        run: |
          if find ./out/make/zip -name "*.zip" -type f 2>/dev/null | grep -q .; then
            echo "ZIP files already exist, skipping manual creation"
            exit 0
          fi
          echo "Makers didn't create ZIP, creating manually..."
          APP_PATH=$(find ./out/package -name "*.app" -type d | head -1)
          if [ -z "$APP_PATH" ]; then
            echo "No .app found, cannot create ZIP"
            exit 1
          fi
          VERSION=$(cat package.json | grep -o '"version": "[^"]*"' | cut -d'"' -f4)
          ARCH="arm64"
          ZIP_NAME="iHosts-darwin-${ARCH}-${VERSION}.zip"
          ZIP_DIR="out/make/zip/darwin/${ARCH}"
          ZIP_PATH="${ZIP_DIR}/${ZIP_NAME}"
          mkdir -p "$ZIP_DIR"
          # Create ZIP - must be created from the app's parent directory to preserve structure
          APP_DIR=$(dirname "$APP_PATH")
          APP_NAME=$(basename "$APP_PATH")
          cd "$APP_DIR"
          # From ./out/package/darwin-arm64, go up 2 levels to root, then to ZIP dir
          zip -r "../../${ZIP_PATH}" "$APP_NAME" 2>&1
          cd "$GITHUB_WORKSPACE"
          echo "Created ZIP: ${ZIP_PATH}"
          if [ -f "${ZIP_PATH}" ]; then
            ls -lh "${ZIP_PATH}"
          else
            echo "ERROR: ZIP file was not created at ${ZIP_PATH}"
            echo "Current directory: $(pwd)"
            echo "APP_DIR was: $APP_DIR"
            echo "Checking what was created:"
            find ./out -name "*.zip" -type f 2>/dev/null || echo "No ZIP files found"
            exit 1
          fi

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.get_tag.outputs.tag }}
          name: Release ${{ steps.get_tag.outputs.tag }}
          body: |
            ## Changes in ${{ steps.get_tag.outputs.tag }}

            See [CHANGELOG.md](CHANGELOG.md) for details.

            ### Downloads

            - **macOS (Apple Silicon)**: Download `iHosts-darwin-arm64-${{ steps.get_version.outputs.version }}.zip`

            ### Installation

            1. Download the appropriate ZIP file for your Mac
            2. Extract the ZIP file
            3. Move `iHosts.app` to your Applications folder
            4. If you see a security warning, right-click the app and select "Open", then click "Open" in the dialog
            5. Open iHosts from Applications

            **Note:** This app is code signed and notarized by Apple. If you encounter any security warnings, please ensure you're downloading from this official release.
          draft: false
          prerelease: false
          files: |
            ./out/make/zip/darwin/**/*.zip

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: macos-builds
          path: |
            ./out/make/zip/darwin/arm64/*.zip
          retention-days: 30

      - name: Cleanup keychain
        if: always()
        run: |
          if [ -n "$CSC_LINK" ]; then
            security delete-keychain build.keychain || true
          fi
        env:
          CSC_LINK: ${{ secrets.CSC_LINK }}
